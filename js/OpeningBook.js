import { GameState } from './GameState.js';

// 定石データ (動的構築用ライン)
// 各手順は [src, dst] のペアの配列
// 座標Index:
// 0:A1(GK), 1:B1(GL), 2:C1(GZ)
// 3:A2,     4:B2(GH), 5:C2
// 6:A3,     7:B3(SH), 8:C3
// 9:A4(SZ), 10:B4(SL), 11:C4(SK)
const OPENING_LINES = [
    // Line 1: 相キリン基本形 (互いに右側の駒を上げる)
    // 先手キリン(C4->C3), 後手キリン(A1->A2), 先手ヒヨコ交換(B3->B2), 後手キリンで取る(A2->B2), 先手ゾウ上げ(A4->A3), 後手ゾウ上げ(C1->C2)
    [[11,8], [0,3], [7,4], [3,4], [9,5], [2,6]],
    
    // Line 2: 先手ヒヨコ突っ込み（悪手）への対応
    // 先手ヒヨコ(B3->B2), 後手キリンで取る(A1->B2)
    [[7,4], [0,4]],
    
    // Line 3: 相ゾウ形 (互いに左側の駒を上げる)
    // 先手ゾウ(A4->A3), 後手ゾウ(C1->C2), 先手キリン(C4->C3), 後手キリン(A1->A2)
    [[9,6], [2,5], [11,8], [0,3]],
    
    // Line 4: キリン上げ合い後の変化 (ライオン活用)
    // 先手キリン(C4->C3), 後手キリン(A1->A2), 先手ライオン(B4->C4 ※キリンの居た場所へ), 後手ライオン(B1->A1)
    [[11,8], [0,3], [10,11], [1,0]], 

    // Line 5: ゾウ上がりへの対抗 (バランス型)
    // 先手ゾウ(A4->A3), 後手キリン(A1->A2), 先手ゾウ(A3->B2), 後手キリン(A2->B2)
    [[9,6], [0,3], [6,4], [3,4]],
    
    // Line 6: 2手目変化 (後手がヒヨコを突くパターン)
    // 先手キリン(C4->C3), 後手ヒヨコ(B2->B3 ※取られる前提の特攻) -> 先手キリンで取る
    [[11,8], [4,7], [8,7]],

    // --- 追加定石 (Enhanced) ---

    // Line 7: 先手ゾウ上がり(A4->A3)に対し、後手もゾウ上がり(C1->C2)
    // その後、先手がヒヨコ交換(B3->B2)に来たら、後手はゾウで取る(C2->B2)
    [[9,6], [2,5], [7,4], [5,4]],

    // Line 8: 先手キリン(C4->C3)に対し、後手ゾウ(C1->C2)
    // 先手がヒヨコ交換(B3->B2)に来たら、後手はゾウで取る(C2->B2)
    [[11,8], [2,5], [7,4], [5,4]],

    // Line 9: 先手が初手でライオンを左上(A3)へ
    // 後手はキリン(A1->A2)で圧力をかける
    [[10,6], [0,3]],

    // Line 10: 先手が初手でライオンを右上(C3)へ
    // 後手はゾウ(C1->C2)で対抗
    [[10,8], [2,5]],

    // Line 11: 千日手模様の回避 (先手がヒヨコを取らずにライオンを動かす展開)
    // キリン上げ合い -> 先手ライオン右移動 -> 後手キリン前進(A2->A3)
    [[11,8], [0,3], [10,11], [3,6]],

    // Line 12: お互いに譲らない展開 (相ゾウからさらに前進)
    // 先手ゾウA3, 後手ゾウC2, 先手ゾウA2(取り込み), 後手ゾウC3(取り込み)
    [[9,6], [2,5], [6,3], [5,8]],
    
    // Line 13: 牽制 (千日手対応)
    // 先手ゾウA3, 後手キリンA2, 先手ゾウ戻る, 後手キリン戻る
    [[9,6], [0,3], [6,9], [3,0]]
];

// 定石構築関数
export function buildOpeningBook() {
    const book = {};
    const rootState = new GameState();
    
    OPENING_LINES.forEach(line => {
        let state = rootState.clone();
        for (let pair of line) {
            const src = pair[0];
            const dst = pair[1];
            
            const key = state.toStringKey();
            const validMoves = state.getValidMoves();
            const move = validMoves.find(m => m.type === 'MOVE' && m.src === src && m.dst === dst);
            
            if (move) {
                // 重複時は上書きしない（最初のライン優先）
                if (!book[key]) {
                    book[key] = move;
                }
                state = state.makeMove(move);
            } else {
                // 手が無効ならこのラインの以降は無視
                break;
            }
        }
    });
    return book;
}